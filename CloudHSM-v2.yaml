AWSTemplateFormatVersion: 2010-09-09
Description: >-
  AWS CloudFormation Template to set up a CloudHSM Cluster using StepFunctions.
  Returns cluster_id
Metadata:
  'AWS::CloudFormation::Interface':
    ParameterGroups:
      - Label:
          default: HSM Cluster Configuration
        Parameters:
          - VPCInput
    ParameterLabels:
      VPCInput:
        default: VPC to launch the CloudHSM Cluster
      ClientInstanceSubnet:
        default: Subnet Id to launch Client Instance into
      InstanceType:
        default: Instance Type
      ImageId:
        default: Latest Amazon Linux AMI ID from SSM

Parameters:
  VPCInput:
    Description: The VPC you wish to deploy the HSM Cluster in.
    Type: 'AWS::EC2::VPC::Id'
  ClientInstanceSubnet:
    Description: Subnet Id to launch Client Instance into
    Type: 'AWS::EC2::Subnet::Id'
  InstanceType:
    Type: String
    AllowedValues:
      - t2.medium
      - t2.large
    Default: t2.medium
    Description: >-
      Enter t2.medium, t2.large. The EC2 instance is a critical component for automating the provisioning.
  ImageId:
    Type: 'AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>'
    Default: /aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-x86_64-ebs
Resources:
  CloudHSMCluster:
    Type: 'Custom::CustomClusterLauncher'
    Properties:
      ServiceToken: !Sub >-
        arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${CustomClusterLauncher}
      VPC_Id: !Ref VPCInput
      CreateSFN_function: !Ref StepFunctionCreateCluster
      DeleteSFN_function: !Ref StepFunctionDeleteCluster
  StatesExecutionRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - !Sub 'states.${AWS::Region}.amazonaws.com'
            Action: 'sts:AssumeRole'
      Path: /
      Policies:
        - PolicyName: StatesExecutionPolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - 'lambda:InvokeFunction'
                Resource: '*'
  StepFunctionCreateCluster:
    Type: 'AWS::StepFunctions::StateMachine'
    Properties:
      DefinitionString: !Sub |-
        {
          "Comment": "Creates a CloudHSM and initializes it",
          "StartAt": "ConfigCluster",
          "States": {
            "ConfigCluster": {
              "Type": "Pass",
              "Next": "CreateCluster"
            },
            "CreateCluster": {
              "Type": "Task",
              "Resource": "arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${CreateCluster}",
              "Next": "wait_for_cluster",
              "ResultPath": "$.cluster_id",
              "Catch": [{
                "ErrorEquals": [ "States.ALL" ],
                "Next": "CFNError",
                "ResultPath": "$.error"
              }]
            },
            "wait_for_cluster": {
              "Type": "Wait",
              "Seconds": 30,
              "Next": "GetClusterStatus"
            },
            "GetClusterStatus": {
              "Type": "Task",
              "Resource": "arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${GetClusterStatus}",
              "Next": "ClusterReady?",
              "ResultPath": "$.Clusterstatus",
              "Catch": [{
                "ErrorEquals": [ "States.ALL" ],
                "Next": "CFNError",
                "ResultPath": "$.error"
              }]
            },
            "ClusterReady?": {
              "Type": "Choice",
              "Choices": [
                {
                  "Variable": "$.Clusterstatus",
                  "StringEquals": "UNINITIALIZED",
                  "Next": "ConfigHSM"
                }
              ],
              "Default": "wait_for_cluster"
            },
              "ConfigHSM": {
                "Type": "Pass",
                "Next": "CreateHSM"
              },
            "CreateHSM": {
              "Type": "Task",
              "Resource": "arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${CreateHSM}",
              "Next": "wait_for_HSM",
              "ResultPath": "$.hsm_id",
              "Catch": [{
                "ErrorEquals": [ "States.ALL" ],
                "Next": "CFNError",
                "ResultPath": "$.error"
              }]
            },
            "wait_for_HSM": {
              "Type": "Wait",
              "Seconds": 30,
              "Next": "GetHSMStatus"
            },
            "GetHSMStatus": {
              "Type": "Task",
              "Resource": "arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${CheckHSMStatus}",
              "Next": "HSMReady?",
              "ResultPath": "$.HSMstatus",
              "Catch": [{
                "ErrorEquals": [ "States.ALL" ],
                "Next": "CFNError",
                "ResultPath": "$.error"
              }]
            },
            "HSMReady?": {
              "Type": "Choice",
              "Choices": [
                {
                  "Variable": "$.HSMstatus",
                  "StringEquals": "ACTIVE",
                  "Next": "RespondToCFN"
                }
              ],
              "Default": "wait_for_HSM"
            },
            "RespondToCFN": {
              "Type": "Task",
              "Resource": "arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${CFNRespond}",
              "End": true
            },
            "CFNError": {
              "Type": "Task",
              "Resource": "arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${CFNError}",
              "End": true}
          }
        }
      RoleArn: !GetAtt 
        - StatesExecutionRole
        - Arn
  StepFunctionDeleteCluster:
    Type: 'AWS::StepFunctions::StateMachine'
    Properties:
      DefinitionString: !Sub |-
        {
          "Comment": "Deletes CloudHSM cluster as provided by PhysicalResourceId",
          "StartAt": "GetClusterInfo",
          "States": {
            "GetClusterInfo": {
              "Type": "Pass",
              "Next": "DeleteHSM"
            },
            "DeleteHSM": {
              "Type": "Task",
              "Resource": "arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${DeleteHSMs}",
              "Next": "wait_for_HSMs",
        		  "ResultPath": "$.hsms",
              "Catch": [{
                "ErrorEquals": [ "States.ALL" ],
                "Next": "CFNError",
                "ResultPath": "$.error"
              }]
            },
            "wait_for_HSMs": {
              "Type": "Wait",
              "Seconds": 30,
              "Next": "GetHSMStatus"
            },
            "GetHSMStatus": {
              "Type": "Task",
              "Resource": "arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${CheckHSMStatus}",
              "Next": "HSMReady?",
              "ResultPath": "$.HSMstatus",
              "Catch": [{
                "ErrorEquals": [ "States.ALL" ],
                "Next": "CFNError",
                "ResultPath": "$.error"
              }]
            },
            "HSMReady?": {
              "Type": "Choice",
              "Choices": [{
                "Variable": "$.HSMstatus",
                "StringEquals": "DELETED",
                "Next": "DeleteCluster"
              }],
              "Default": "wait_for_HSMs"
            },
            "DeleteCluster": {
              "Type": "Task",
              "Resource": "arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${DeleteCluster}",
              "Next": "wait_for_cluster",
              "ResultPath": "$.cluster",
              "Catch": [{
                "ErrorEquals": [ "States.ALL" ],
                "Next": "CFNError",
                "ResultPath": "$.error"
              }]
            },
            "wait_for_cluster": {
              "Type": "Wait",
              "Seconds": 30,
              "Next": "GetClusterStatus"
            },
            "GetClusterStatus": {
              "Type": "Task",
              "Resource": "arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${GetClusterStatus}",
              "Next": "ClusterReady?",
              "ResultPath": "$.Clusterstatus",
              "Catch": [{
                "ErrorEquals": [ "States.ALL" ],
                "Next": "CFNError",
                "ResultPath": "$.error"
              }]
            },
            "ClusterReady?": {
              "Type": "Choice",
              "Choices": [{
                "Variable": "$.Clusterstatus",
                "StringEquals": "DELETED",
                "Next": "RespondToCFN"
              }],
              "Default": "wait_for_cluster"
            },
            "RespondToCFN": {
              "Type": "Task",
              "Resource": "arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${CFNRespond}",
              "End": true
            },
            "CFNError": {
              "Type": "Task",
              "Resource": "arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${CFNError}",
              "End": true
            }
          }
        }
      RoleArn: !GetAtt 
        - StatesExecutionRole
        - Arn
  CloudHSMLambdaExecutionRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - 'sts:AssumeRole'
      Path: /
      Policies:
        - PolicyName: CloudHSMLambdaPolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - 'iam:CreateServiceLinkedRole'
                  - 'logs:CreateLogGroup'
                  - 'logs:CreateLogStream'
                  - 'logs:PutLogEvents'
                  - 'ec2:Describe*'
                  - 'ec2:AuthorizeSecurityGroup*'
                  - 'ec2:RevokeSecurityGroup*'
                  - 'ec2:CreateSecurityGroup'
                  - 'ec2:DeleteSecurityGroup'
                  - 'ec2:CreateNetworkInterface'
                  - 'ec2:CreateTags'
                  - 'ec2:DeleteNetworkInterface'
                  - 'ec2:DetachNetworkInterface'
                  - 'cloudhsm:*'
                  - 'states:*'
                Resource:
                  - '*'
  CustomClusterLauncher:
    Type: 'AWS::Lambda::Function'
    Properties:
      Code:
        ZipFile: |
          import boto3
          import json
          import time
          import os
          from botocore.vendored import requests
          SFN = boto3.client('stepfunctions')

          def lambda_handler(event, context):
              CreatestepArn = event['ResourceProperties']['CreateSFN_function']
              DeletestepArn = event['ResourceProperties']['DeleteSFN_function']
              print('ResponseURL is ' + str(event['ResponseURL']))
              if (os.environ['AWS_REGION'] == 'ap-northeast-3') or (os.environ['AWS_REGION'] == 'sa-east-1'):
                  responseStatus = 'FAILED'
                  responseData = {'Failed': 'Unsupported Region.'}
                  time.sleep(3)
                  sendResponse(event, context, responseStatus, responseData)
              print('REQUEST BODY:n' + str(event))
              try:
                  if event['RequestType'] == 'Delete':
                      print('delete')
                      PhysicalResourceId = event['PhysicalResourceId']
                      print('Trying to invoke ' + str(DeletestepArn) + ' to delete Cluster')
                      response = SFN.describe_state_machine(stateMachineArn=str(DeletestepArn))
                      print(response)
                      SFN.start_execution(stateMachineArn=DeletestepArn,input=json.dumps(event))
                      return 0
                  elif event['RequestType'] == 'Create':
                      print('create')
                      #The rest of your create logic goes here
                      print('Trying to invoke ' + str(CreatestepArn) + ' to create Cluster')
                      print(SFN.describe_state_machine(stateMachineArn=CreatestepArn))
                      SFN.start_execution(stateMachineArn=CreatestepArn,input=json.dumps(event))
                      return 0
                  elif event['RequestType'] == 'Update':
                      print('update')
                      print('Update not supported.')
                      PhysicalResourceId = event['PhysicalResourceId']
                      sendResponse(event, context, 'SUCCESS', {'cluster_id': PhysicalResourceId}, None, PhysicalResourceId)
                  responseStatus = 'SUCCESS'
                  responseData = {'Success': 'Everything worked.'}
              except:
                  responseStatus = 'FAILED'
                  responseData = {'Failed': 'Something bad happened.'}
                  time.sleep(3)
              
              sendResponse(event, context, responseStatus, responseData)

          def sendResponse(event, context, responseStatus, responseData, reason=None, physical_resource_id=None):
              responseBody = {
                  'Status': responseStatus,
                  'Reason': 'See the details in CloudWatch Log Stream: ' + context.log_stream_name,
                  'PhysicalResourceId': physical_resource_id or context.log_stream_name,
                  'StackId': event['StackId'],
                  'RequestId': event['RequestId'],
                  'LogicalResourceId': event['LogicalResourceId'],
                  'Data': responseData
              }

              print('RESPONSE BODY:/n' + json.dumps(responseBody))
              responseUrl = event['ResponseURL']
              json_responseBody = json.dumps(responseBody)

              headers = {
                'content-type' : '',
                'content-length' : str(len(json_responseBody))
              }

              try:
                  response = requests.put(responseUrl, data=json_responseBody, headers=headers)
                  print('Status code: ' + response.reason)
              except Exception as e:
                  print('send(..) failed executing requests.put(..): ' + str(e))
      Handler: index.lambda_handler
      Runtime: python3.7
      Timeout: '20'
      Role: !GetAtt 
        - CloudHSMLambdaExecutionRole
        - Arn
  CreateCluster:
    Type: 'AWS::Lambda::Function'
    Properties:
      Code:
        ZipFile:
          Fn::Sub:
            - |
              import json
              import boto3
              HSM = boto3.client('cloudhsmv2')
              EC2 = boto3.client('ec2')
              def lambda_handler(event, context):
                  print(event)
                  target_vpc = event['ResourceProperties']['VPC_Id']
                  subnets_and_az = dict()
                  vpc_info = EC2.describe_subnets(Filters=[{
                    'Name': 'vpc-id',
                    'Values': [target_vpc]
                  }])

                  for subnet in vpc_info['Subnets']:
                      subnets_and_az[subnet['AvailabilityZone']] = subnet['SubnetId']

                  subnets = list(subnets_and_az.values())
                  # At most one subnet is allowed per availability zone when creating cluster.
                  print('Subnets ' + str(subnets) + ' are unique per-az found in the VPC ' + str(target_vpc))
                  Cluster = HSM.create_cluster(SubnetIds=subnets,HsmType='hsm1.medium')
                  cluster_id = Cluster['Cluster']['ClusterId']

                  return cluster_id
            - {}
      Handler: index.lambda_handler
      Runtime: python3.7
      Timeout: '20'
      Role: !GetAtt 
        - CloudHSMLambdaExecutionRole
        - Arn
  GetClusterStatus:
    Type: 'AWS::Lambda::Function'
    Properties:
      Code:
        ZipFile: |
            import json
            import boto3
            HSM = boto3.client('cloudhsmv2')

            def lambda_handler(event, context):
                print(event)
                if event['RequestType'] == 'Create':
                    cluster_id = event['cluster_id']
                    cluster = HSM.describe_clusters(Filters={'clusterIds': [cluster_id]})
                    print('Finding state for cluster ' + str(cluster))
                    return cluster['Clusters'][0]['State']
                elif event['RequestType'] == 'Delete':
                    cluster_id = event['PhysicalResourceId']
                    print('Finding state for Physical Resource ' + str(cluster_id))
                    cluster = HSM.describe_clusters(Filters={'clusterIds': [cluster_id]})
                    if not cluster['Clusters']:
                        return 'DELETED'
                    else:
                        return cluster['Clusters'][0]['State']
      Handler: index.lambda_handler
      Runtime: python3.7
      Timeout: '20'
      Role: !GetAtt 
        - CloudHSMLambdaExecutionRole
        - Arn
  CreateHSM:
    Type: 'AWS::Lambda::Function'
    Properties:
      Code:
        ZipFile: |
          import json
          import boto3
          HSM = boto3.client('cloudhsmv2')

          def lambda_handler(event, context):
              print(event)
              target_vpc = event['ResourceProperties']['VPC_Id']
              cluster_id = event['cluster_id']
              az_names= []
              cluster_info = HSM.describe_clusters(Filters={'clusterIds': [cluster_id]})
              print(cluster_info)
              for az in cluster_info['Clusters'][0]['SubnetMapping']:
                  az_names.append(az)
              print('AZs ' + str(az_names) + ' are found in the VPC ' + str(target_vpc))
              try:
                  hsm_device = HSM.create_hsm(ClusterId=cluster_id,AvailabilityZone=az_names[0])
                  print(hsm_device)
                  return hsm_device['Hsm']['HsmId']
              except HSM.exceptions.CloudHsmServiceException as e: # Exception as e:
                  print(e)
                  print('Trying to create HSM in AZ ' + str(az_names[1]) + ' instead.')
                  try:
                      hsm_device = HSM.create_hsm(ClusterId=cluster_id,AvailabilityZone=az_names[1])
                      print(hsm_device)
                  except HSM.exceptions.CloudHsmServiceException as f:
                      print(f)
                      print('Failed in 2 AZs - exiting with no HSM deployed')
      Handler: index.lambda_handler
      Runtime: python3.7
      Timeout: '20'
      Role: !GetAtt 
        - CloudHSMLambdaExecutionRole
        - Arn
  CheckHSMStatus:
    Type: 'AWS::Lambda::Function'
    Properties:
      Code:
        ZipFile: |
          import json
          import boto3
          HSM = boto3.client('cloudhsmv2')

          def lambda_handler(event, context):
              print(event)
              states = dict()
              if event['RequestType'] == 'Create':
                  cluster_id = event['cluster_id']
                  cluster = HSM.describe_clusters(Filters={'clusterIds': [cluster_id]})
                  print(cluster)
                  hsm = cluster['Clusters'][0]['Hsms'][0]
                  print(hsm)
                  print(hsm['State'])
                  return hsm['State']
              elif event['RequestType'] == 'Delete':
                  cluster_id = event['PhysicalResourceId']
                  cluster = HSM.describe_clusters(Filters={'clusterIds': [cluster_id]})
                  print(cluster)
                  if not cluster['Clusters'][0]['Hsms']:
                      return 'DELETED'
                  else:
                      for hsm in cluster['Clusters'][0]['Hsms']:
                          states[hsm['HsmId']] = hsm['State']
                      return states
      Handler: index.lambda_handler
      Runtime: python3.7
      Timeout: '20'
      Role: !GetAtt 
        - CloudHSMLambdaExecutionRole
        - Arn
  DeleteCluster:
    Type: 'AWS::Lambda::Function'
    Properties:
      Code:
        ZipFile: |
          import json
          import boto3
          HSM = boto3.client('cloudhsmv2')
          def lambda_handler(event, context):
              print(event)
              cluster_id = event['PhysicalResourceId']
              print('Deleting Cluster ' + str(cluster_id))
              HSM.delete_cluster(ClusterId=cluster_id)
              return {'Deleting': cluster_id}
      Handler: index.lambda_handler
      Runtime: python3.7
      Timeout: '20'
      Role: !GetAtt 
        - CloudHSMLambdaExecutionRole
        - Arn
  DeleteHSMs:
    Type: 'AWS::Lambda::Function'
    Properties:
      Code:
        ZipFile: |
          import json
          import boto3
          HSM = boto3.client('cloudhsmv2')

          def lambda_handler(event, context):
              print(event)
              cluster_id = event['PhysicalResourceId']
              cluster_info = HSM.describe_clusters(Filters={'clusterIds': [cluster_id]})
              print(cluster_info)
              hsms = []
              for hsm in cluster_info['Clusters'][0]['Hsms']:
                  print('Deleting HSM ' + str(hsm['HsmId']))
                  hsms.append(hsm['HsmId'])
                  HSM.delete_hsm(ClusterId=cluster_id,HsmId=hsm['HsmId'])
              return {'Deleting': hsms}
      Handler: index.lambda_handler
      Runtime: python3.7
      Timeout: '20'
      Role: !GetAtt 
        - CloudHSMLambdaExecutionRole
        - Arn
  CFNError:
    Type: 'AWS::Lambda::Function'
    Properties:
      Code:
        ZipFile: |
          import json
          import cfnresponse

          def lambda_handler(event, context):
              responseData = {}
              cfnresponse.send(event, context, cfnresponse.FAILED, responseData, "CloudHSMCluster")
      Handler: index.lambda_handler
      Runtime: python3.7
      Timeout: '20'
      Role: !GetAtt
        - CloudHSMLambdaExecutionRole
        - Arn
  CFNRespond:
    Type: 'AWS::Lambda::Function'
    Properties:
      Code:
        ZipFile: |
          import json
          from botocore.vendored import requests

          def lambda_handler(event, context):
              if event['RequestType'] == 'Create':
                  cluster_id = event['cluster_id']
                  if event['HSMstatus'] == 'ACTIVE':
                      print('Responding to CloudFormation with SUCCESS')
                      sendResponse(event, context, 'SUCCESS', {'cluster_id': cluster_id, 'hsm_id': event['hsm_id']}, None, cluster_id)
                  else:
                      print('Responding to CloudFormation with FAILED')
                      sendResponse(event, context, 'FAILED', {'cluster_id': cluster_id, 'hsm_id': event['hsm_id']}, None, cluster_id)
                  return
              elif event['RequestType'] == 'Delete':
                  cluster_id = event['PhysicalResourceId']
                  sendResponse(event, context, 'SUCCESS', {'cluster_id': cluster_id}, None, cluster_id)
                  return

          def sendResponse(event, context, responseStatus, responseData, reason=None, physical_resource_id=None):
              responseBody = {
                  'Status': responseStatus,
                  'Reason': 'See the details in CloudWatch Log Stream: ' + context.log_stream_name,
                  'PhysicalResourceId': physical_resource_id or context.log_stream_name,
                  'StackId': event['StackId'],
                  'RequestId': event['RequestId'],
                  'LogicalResourceId': event['LogicalResourceId'],
                  'Data': responseData
              }

              print('RESPONSE BODY:/n' + json.dumps(responseBody))
              responseUrl = event['ResponseURL']
              json_responseBody = json.dumps(responseBody)

              headers = {
                  'content-type' : '',
                  'content-length' : str(len(json_responseBody))
              }

              try:
                  response = requests.put(responseUrl, data=json_responseBody, headers=headers)
                  print('Status code: ' + response.reason)
              except Exception as e:
                  print('send(..) failed executing requests.put(..): ' + str(e))
      Handler: index.lambda_handler
      Runtime: python3.7
      Timeout: '20'
      Role: !GetAtt 
        - CloudHSMLambdaExecutionRole
        - Arn
  InitialHSMPassword:
    Type: 'AWS::SecretsManager::Secret'
    Properties:
      Name: !Sub '/cloudhsm/initial-password-${CloudHSMCluster.cluster_id}'
      Description: Stores the initial password for the CloudHSM
      GenerateSecretString:
        SecretStringTemplate: '{"username": "admin"}'
        GenerateStringKey: "password"
        PasswordLength: 10
        ExcludePunctuation: true
  ClientInstanceSecurityGroup:
    Type: 'AWS::EC2::SecurityGroup'
    Properties:
      GroupDescription: Client Instance Security Group
      VpcId: !Ref VPCInput
  ClientInstance:
    Type: 'AWS::EC2::Instance'
    DependsOn: [ "CloudHSMCluster", "InitialHSMPassword" ]
    CreationPolicy:
      ResourceSignal:
        Count: 1
        Timeout: PT2H
    Properties:
      InstanceType: !Ref InstanceType
      ImageId: !Ref ImageId
      IamInstanceProfile: !Ref ClientInstanceProfile
      SubnetId: !Ref ClientInstanceSubnet
      SecurityGroupIds: [
        !Ref ClientInstanceSecurityGroup
      ]
      Tags:
        - Key: Name
          Value: !Sub
            - CloudHSM-${Cluster_Id}
            - { Cluster_Id: !GetAtt CloudHSMCluster.cluster_id }
      UserData:
        Fn::Base64:
          Fn::Sub:
            - |
              #!/bin/bash

              echo "Working directory is: /root"
              cd /root

              echo "Start client instance user script: `date`"
              sudo yum update -y
              sleep 10
              sudo yum install jq expect wget curl openssl amazon-cloudwatch-agent -y

              echo -e '#!/usr/bin/expect -f
              set password [lindex $argv 0]
              spawn /opt/cloudhsm/bin/cloudhsm_mgmt_util /opt/cloudhsm/etc/cloudhsm_mgmt_util.cfg
              expect -exact "aws-cloudhsm>"
              send -- "listUsers\\r"
              expect -exact "aws-cloudhsm>"
              send -- "loginHSM PRECO admin password\\r"
              expect -exact "aws-cloudhsm>"
              send -- "changePswd PRECO admin $password\\r"
              expect -- "Do you want to continue(y/n)?"
              send -- "y\\r"
              expect -exact "aws-cloudhsm>"
              send -- "listUsers\\r"
              expect -exact "aws-cloudhsm>"
              send -- "quit\\r"
              expect eof' > cHSM.expect
              chmod +x cHSM.expect

              echo -e '#!/usr/bin/expect -f
              set password [lindex $argv 0]
              spawn /opt/cloudhsm/bin/cloudhsm_mgmt_util /opt/cloudhsm/etc/cloudhsm_mgmt_util.cfg
              expect -exact "aws-cloudhsm>"
              send -- "listUsers\\r"
              expect -exact "aws-cloudhsm>"
              send -- "loginHSM CO admin $password\\r"
              expect -exact "aws-cloudhsm>"
              send -- "createUser CU kmsuser $password\\r"
              expect -- "Do you want to continue(y/n)?"
              send -- "y\\r"
              expect -exact "aws-cloudhsm>"
              send -- "listUsers\\r"
              expect "aws-cloudhsm>"
              send -- "quit\\r"
              expect eof' > CreateKMSUser.expect
              chmod +x CreateKMSUser.expect

              echo -e '{
                "agent": {
                  "run_as_user": "root"
                },
                "logs": {
                  "logs_collected": {
                    "files": {
                      "collect_list": [
                        {
                          "file_path": "/var/log/messages",
                          "log_group_name": "/aws/ec2/CloudHSM-${Cluster_Id}",
                          "log_stream_name": "messages"
                        },
                        {
                          "file_path": "var/log/cloud-init-output.log",
                          "log_group_name": "/aws/ec2/CloudHSM-${Cluster_Id}",
                          "log_stream_name": "cloud-init-output.log"
                        }
                      ]
                    }
                  }
                }
              }' > /opt/aws/amazon-cloudwatch-agent/etc/amazon-cloudwatch-agent.json
              chmod 644 /opt/aws/amazon-cloudwatch-agent/etc/amazon-cloudwatch-agent.json
              /opt/aws/amazon-cloudwatch-agent/bin/amazon-cloudwatch-agent-ctl -a stop
              /opt/aws/amazon-cloudwatch-agent/bin/amazon-cloudwatch-agent-ctl -a fetch-config -m ec2 -c file:/opt/aws/amazon-cloudwatch-agent/etc/amazon-cloudwatch-agent.json -s

              wget https://s3.amazonaws.com/cloudhsmv2-software/CloudHsmClient/EL7/cloudhsm-client-latest.el7.x86_64.rpm
              sudo yum install -y ./cloudhsm-client-latest.el7.x86_64.rpm
              export instance_id=$(curl 169.254.169.254/latest/meta-data/instance-id/)
              echo $instance_id
              export region=$(curl http://169.254.169.254/latest/dynamic/instance-identity/document|grep region|awk -F\" '{print $4}')
              export cluster_id=${Cluster_Id}
              sleep 10
              echo Creating Key
              sudo openssl genrsa -out customerCA.key 4096
              echo Creating CA
              sudo openssl req -new -x509 -days 3652 -key customerCA.key -out customerCA.crt -subj "/C=IE/ST=$region/O=CloudHSM/OU=Amazon/CN=$cluster_id"
              aws cloudhsmv2 describe-clusters --filters clusterIds=$cluster_id --region $region --output text --query 'Clusters[].Certificates.ClusterCsr' > ${!cluster_id}_ClusterCsr.csr
              sudo openssl x509 -req -days 3652 -in ${!cluster_id}_ClusterCsr.csr -CA customerCA.crt -CAkey customerCA.key -CAcreateserial -out ${!cluster_id}_CustomerHsmCertificate.crt
              sudo cp customerCA.crt /opt/cloudhsm/etc/customerCA.crt
              aws cloudhsmv2 initialize-cluster --cluster-id $cluster_id --signed-cert file://${!cluster_id}_CustomerHsmCertificate.crt --trust-anchor file://customerCA.crt --region $region

              export c_init=""
              while [ "$c_init" != "INITIALIZED" ]; do
                echo Waiting for Cluster to be initialized...
                c_init=$(aws cloudhsmv2 describe-clusters --filters clusterIds=$cluster_id --query 'Clusters[].State' --region $region --output text)
                sleep 5
              done

              echo Cluster Initialized!
              aws cloudhsmv2  describe-clusters --filters clusterIds=$cluster_id --query "Clusters[0].Hsms[0].EniIp" --output text --region $region > hsm_ip.txt || (/opt/aws/bin/cfn-signal -s false --stack ${AWS::StackName} --region $region --resource ClientInstance;exit 127)

              # Setup inbound rule to allow EC2 instance security group to access HSM
              export instance_group=$(aws ec2 describe-instances --instance-ids $instance_id --query Reservations[*].Instances[*].SecurityGroups[*].GroupId --output text --region $region || echo failed)
              echo "instance_group: $instance_group"
              [[ $instance_group == 'failed' ]] && /opt/aws/bin/cfn-signal -s false --stack ${AWS::StackName} --region $region --resource ClientInstance

              export security_group=$(aws cloudhsmv2 describe-clusters --filters clusterIds=$cluster_id --query Clusters[*].SecurityGroup[] --output text --region $region || echo failed)
              echo "security_group: $security_group"
              [[ $security_group == 'failed' ]] && /opt/aws/bin/cfn-signal -s false --stack ${AWS::StackName} --region $region --resource ClientInstance

              aws ec2 authorize-security-group-ingress --group-id $security_group --source-group $instance_group --protocol all --region $region || (/opt/aws/bin/cfn-signal -s false --stack ${AWS::StackName} --region $region --resource ClientInstance;echo "Failed to configure HSM security group";exit 127)
              
              sudo /opt/cloudhsm/bin/configure -a `cat hsm_ip.txt`
              sudo systemctl start cloudhsm-client.service
              
              # get initial password
              export initial_password=$(aws secretsmanager get-secret-value --secret-id ${SMPasswordRef} --region us-east-2 | jq '.SecretString | fromjson.password' || echo failed)
              [[ $initial_password == 'failed' ]] && echo "Failed to retrieve password from secrets manager" && /opt/aws/bin/cfn-signal -s false --stack ${AWS::StackName} --region $region --resource ClientInstance && exit 127

              # Give cloudhsm-client service time to startup
              sleep 5
              
              # Redirect expect output to /dev/null to hide password and keep it from showing up in AWS Cloudwatch
              echo "Running expect script cHSM.expect and CreateKMSUser.expect. redirecting output to hide password."

              { time ./cHSM.expect $initial_password; } 2> /home/ec2-user/cHSM-time.txt 1> /dev/null
              { time ./CreateKMSUser.expect $initial_password; } 2> /home/ec2-user/CreateKMSUser-time.txt 1> /dev/null

              # Wait for Cluster to become Active
              export c_init=""
              while [ "$c_init" != "ACTIVE" ]; do
                echo Waiting for Cluster to be ACTIVE...
                c_init=$(aws cloudhsmv2 describe-clusters --filters clusterIds=$cluster_id --query 'Clusters[].State' --region $region --output text)
                sleep 5
              done

              # Next steps are creating a another HSM for KMS
              export available_az=$(aws cloudhsmv2 describe-clusters --filters clusterIds=$cluster_id --region $region --query 'Clusters' | jq ' [ .[0].SubnetMapping | keys ][0] - [ .[0].Hsms[0].AvailabilityZone ] | .[0]' | jq -r '.' || echo failed)
              echo "available_az: $available_az"
              [[ $available_az == 'failed' ]] && (/opt/aws/bin/cfn-signal -s false --stack ${AWS::StackName} --region $region --resource ClientInstance;exit 127)

              # Add new HSM
              aws cloudhsmv2 create-hsm --cluster-id $cluster_id --availability-zone $available_az --region $region || (/opt/aws/bin/cfn-signal -s false --stack ${AWS::StackName} --region $region --resource ClientInstance;exit 127)

              # Wait for new HSM to be listed
              export number_hsm=$(aws cloudhsmv2 describe-clusters --filters clusterIds=$cluster_id --query 'Clusters[0].Hsms[].State' --region $region | jq length || echo failed)
              [[ $number_hsm == 'failed' ]] && (/opt/aws/bin/cfn-signal -s false --stack ${AWS::StackName} --region $region --resource ClientInstance;exit 127)
              while [[ $number_hsm -lt 2 ]];do
                number_hsm=$(aws cloudhsmv2 describe-clusters --filters clusterIds=$cluster_id --query 'Clusters[0].Hsms[].State' --region $region | jq length)
                echo Waiting for HSM. Length is $number_hsm
                sleep 5
              done

              # Wait for new HSM to be Active
              while [[ ! -z $(aws cloudhsmv2 describe-clusters --filters clusterIds=$cluster_id --query 'Clusters[0].Hsms[].State' --region $region --output text | egrep 'CREATE') ]];do
                echo "Waiting for HSM to become active..."
                sleep 5;
              done

              # Create a custom key store and store custom_key_store_id
              echo "custom key store id part of user script: `date`"
              export custom_key_store_id=$(aws kms create-custom-key-store --custom-key-store-name ${Cluster_Id} --cloud-hsm-cluster-id $cluster_id --key-store-password $initial_password --trust-anchor-certificate file://customerCA.crt --region $region | jq -r '.CustomKeyStoreId' || echo failed)
              echo "custom_key_store_id: $custom_key_store_id"
              [[ $custom_key_store_id == 'failed' ]] && (/opt/aws/bin/cfn-signal -s false --stack ${AWS::StackName} --region $region --resource ClientInstance;exit 127)
              
              # Connect KMS to CloudHSM
              n=0
              while true
              do
                aws kms connect-custom-key-store --custom-key-store-id $custom_key_store_id --region $region && echo "Succeeded in aws kms connect-custom-key-store" && break
                [[ $n -ge 5 ]] && (/opt/aws/bin/cfn-signal -s false --stack ${AWS::StackName} --region $region --resource ClientInstance;exit 127)
                n=$((n+1))
                echo "Retrying in $((n*5)) for aws kms connect-custom-key-store"
                sleep $((n*5))
              done

              # Wait for KMS to connect to CloudHSM
              while [[ -z $(aws kms describe-custom-key-stores --custom-key-store-id $custom_key_store_id --region $region | egrep '\bCONNECTED\b') ]];do
                echo "Waiting for KMS to connect to CloudHSM..."
                sleep 30
              done

              /opt/aws/bin/cfn-signal -s true --stack ${AWS::StackName} --region $region --resource ClientInstance

            - Cluster_Id: !GetAtt CloudHSMCluster.cluster_id
              SMPasswordRef: !Ref InitialHSMPassword
  ClientInstanceRole:
    Type: 'AWS::IAM::Role'
    DependsOn: CloudHSMCluster
    Properties:
      MaxSessionDuration: 7200
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore'
        - 'arn:aws:iam::aws:policy/CloudWatchAgentServerPolicy'
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - ec2.amazonaws.com
            Action:
              - 'sts:AssumeRole'
      Path: /
  ClientInstanceProfile:
    Type: 'AWS::IAM::InstanceProfile'
    DependsOn: CloudHSMCluster
    Properties:
      Path: /
      Roles:
        - !Ref ClientInstanceRole
  ClientInstanceRolePolicy:
    Type: 'AWS::IAM::Policy'
    DependsOn: CloudHSMCluster
    Properties:
      PolicyName: CloudHSMAccess
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action:
              - 'ec2:Describe*'
              - 'ec2:AuthorizeSecurityGroup*'
              - 'ec2:RevokeSecurityGroupEgress'
              - 'ec2:Describe*'
              - 'ec2:AuthorizeSecurityGroup*'
              - 'ec2:RevokeSecurityGroup*'
              - 'ec2:CreateSecurityGroup'
              - 'ec2:DeleteSecurityGroup'
              - 'ec2:CreateNetworkInterface'
              - 'ec2:CreateTags'
              - 'ec2:DeleteNetworkInterface'
              - 'ec2:DetachNetworkInterface'
            Resource: '*'
          - Effect: Allow
            Action:
              - cloudhsm:CreateCluster
              - cloudhsm:CreateHsm
              - cloudhsm:Describe*
              - cloudhsm:InitializeCluster
              - cloudhsm:TagResource
              - cloudhsm:ListTags
            Resource: '*'
          - Effect: Allow
            Action:
              - kms:CreateCustomKeyStore
              - kms:ConnectCustomKeyStore
              - kms:DescribeCustomKeyStores
              - kms:UpdateCustomKeyStore
              - kms:DisconnectCustomKeyStore
              - kms:Decrypt
              - iam:CreateServiceLinkedRole
              - secretsmanager:ListSecrets
            Resource: '*'
          - Effect: Allow
            Action:
              - "secretsmanager:DescribeSecret"
              - "secretsmanager:GetSecretValue"
            Resource: !Ref InitialHSMPassword
      Roles:
        - !Ref ClientInstanceRole
Outputs:
  ClusterInfo:
    Description: The cluster_id value of the Cluster that has been set up
    Value: !GetAtt 
      - CloudHSMCluster
      - cluster_id
